# **AURAND-INTEGRATION-TEST**
base on [test-tube](https://github.com/osmosis-labs/test-tube) library

### Flow
- build shared library from Go code which content Aura chain logic (.dll for window, .so for linux)
- load shared library and provide code to simulate actual chain logic in Rust
- load smart contract wasm files then write test logic 

### Simulate Aura Chain
* `packages/test-tube`
a Rust generic library for building testing environments for [CosmWasm](https://cosmwasm.com/) smart contracts

* `packages/aura-test-tube/libauratesttube`
    - `artifacts`
    - `result`
    - `testenv`

- `artifacts` Code generated by cmd/cgo; *DO NOT EDIT*
- `result` error handler
- `testenv` provides logic to simulate a actual cosmos chain (with each different chain we will modify this folder to match it's logic)

in `main.go`, we define all exported functions here

**Notify:** imported cosmos-sdk version must match with version use for tested chain. With euphoria-2, the version is *v0.45.11*

### Write Test

- **test file:** /packages/aura-test-tube/src/runner/app.rs

example

* `QueryAllBalances`

Query all balances of specific address
```Rust
        use cosmrs::proto::cosmos::bank::v1beta1::{
            QueryAllBalancesRequest, QueryAllBalancesResponse
        }

        ...

        let app = AuraTestApp::default(); // generate Test app which act as a chain

        let acc = app.init_account(&coins(100_000_000_000, "ueaura")).unwrap(); // init random account with some ueaura
        let addr = acc.address(); // get account's address

        let denom_creation_fee: Vec<ReturnCoin> = app
            .query::<QueryAllBalancesRequest,QueryAllBalancesResponse>(
                "/cosmos.bank.v1beta1.Query/AllBalances", // router URL
                &QueryAllBalancesRequest {
                    address: addr,
                    pagination: None,
                },
            )
            .unwrap()
            .balances.iter().map(|c| {ReturnCoin{amount: c.amount.clone(), denom: c.denom.clone()}}) // get account balances
            .collect(); 

        assert_eq!(denom_creation_fee, vec![ReturnCoin{
            denom: String::from("ueaura"),
            amount: String::from("100000000000")
        }]); // check if balances init correctly
```

* `InstantiateMsg` contract
```Rust
        let app = AuraTestApp::default(); // generate Test app which act as a chain
        
        let acc = app.init_account(&coins(100_000_000_000, "ueaura")).unwrap();// init random account with some ueaura
        let addr = acc.address(); // get account's address


        let wasm = Wasm::new(&app); // wasm handler 
        let wasm_byte_code = std::fs::read("./test_artifacts/aurand.wasm").unwrap(); // load contract wasm 
        let code_id = wasm
            .store_code(
                &wasm_byte_code, // byte code
                None, // permission
                &acc // signer
            )
            .unwrap()
            .data
            .code_id; // store wasm code to chain
        assert_eq!(code_id, 1); // check if code id correct

        let contract_addr = wasm
            .instantiate(
                code_id,
                &InstantiateMsg {
                    nois_proxy: "...", 
                    time_expired: 5, 
                    time_per_block: 5, 
                    bounty_denom: "ueaura",
                    fee: "300",
                    nois_fee: "300",
                    callback_limit_gas: 150000u64,
                    max_callback: 5u32,
                }, // instantiateMsg for aurand contract
                None, // admin
                Some("aurand"), // label
                &[], // funds
                &acc, // signer
            )
            .unwrap()
            .data
            .address; // get contract address
        
        ...

         // query something
        let query_msg = wasm
            .query::<QueryMsg, SomeQueryResponse>(
                &contract_addr, // contract address
                &QueryMsg::SomeQuery {} // query defined in contract
            )
            .unwrap();

        // execute something
        wasm.execute::<ExecuteMsg>(
            &contract_addr,
            &ExecuteMsg::SomeExecute {},
            &[], // funds
            &acc, // signer
        )
        .unwrap();

```

